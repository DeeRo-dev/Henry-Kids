{"version":3,"file":"react-easy-crop.min.js","sources":["../../src/helpers.ts","../../src/index.tsx"],"sourcesContent":["import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  containerWidth: number,\n  containerHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = rotateSize(mediaWidth, mediaHeight, rotation)\n  const fittingWidth = Math.min(width, containerWidth)\n  const fittingHeight = Math.min(height, containerHeight)\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight,\n    }\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect,\n  }\n}\n\n/**\n * Compute media zoom.\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\n */\nexport function getMediaZoom(mediaSize: MediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height\n    ? mediaSize.width / mediaSize.naturalWidth\n    : mediaSize.height / mediaSize.naturalHeight\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n\n  return clamp(position, -maxPosition, maxPosition)\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition ? limitArea : noOp\n\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  // calculate the crop area in percentages\n  // in the rotated space\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width) *\n        100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) /\n        mediaBBoxSize.height) *\n        100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaBBoxSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaBBoxSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.width,\n      (croppedAreaPercentages.width * mediaNaturalBBoxSize.width) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.height,\n      (croppedAreaPercentages.height * mediaNaturalBBoxSize.height) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.width - sizePixels.width,\n        (croppedAreaPercentages.x * mediaNaturalBBoxSize.width) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.height - sizePixels.height,\n        (croppedAreaPercentages.y * mediaNaturalBBoxSize.height) / 100\n      )\n    ),\n  }\n\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPercentages.\n */\nexport function getInitialCropFromCroppedAreaPercentages(\n  croppedAreaPercentages: Area,\n  mediaSize: MediaSize,\n  rotation: number,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n) {\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  // This is the inverse process of computeCroppedArea\n  const zoom = clamp(\n    (cropSize.width / mediaBBoxSize.width) * (100 / croppedAreaPercentages.width),\n    minZoom,\n    maxZoom\n  )\n\n  const crop = {\n    x:\n      (zoom * mediaBBoxSize.width) / 2 -\n      cropSize.width / 2 -\n      mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y:\n      (zoom * mediaBBoxSize.height) / 2 -\n      cropSize.height / 2 -\n      mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100),\n  }\n\n  return { crop, zoom }\n}\n\n/**\n * Compute zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize: Size\n): number {\n  const mediaZoom = getMediaZoom(mediaSize)\n\n  return cropSize.height > cropSize.width\n    ? cropSize.height / (croppedAreaPixels.height * mediaZoom)\n    : cropSize.width / (croppedAreaPixels.width * mediaZoom)\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  rotation = 0,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n): { crop: Point; zoom: number } {\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  const zoom = clamp(\n    getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize),\n    minZoom,\n    maxZoom\n  )\n\n  const cropZoom =\n    cropSize.height > cropSize.width\n      ? cropSize.height / croppedAreaPixels.height\n      : cropSize.width / croppedAreaPixels.width\n\n  const crop = {\n    x:\n      ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y:\n      ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) *\n      cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\nexport function getRadianAngle(degreeValue: number) {\n  return (degreeValue * Math.PI) / 180\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function rotateSize(width: number, height: number, rotation: number): Size {\n  const rotRad = getRadianAngle(rotation)\n\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),\n  }\n}\n\n/**\n * Clamp value between min and max\n */\nexport function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\n/**\n * Combine multiple class names into a single string.\n */\nexport function classNames(...args: (boolean | string | number | undefined | void | null)[]) {\n  return args\n    .filter((value) => {\n      if (typeof value === 'string' && value.length > 0) {\n        return true\n      }\n\n      return false\n    })\n    .join(' ')\n    .trim()\n}\n","import React from 'react'\nimport normalizeWheel from 'normalize-wheel'\nimport { Area, MediaSize, Point, Size, VideoSrc } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n  getInitialCropFromCroppedAreaPercentages,\n  classNames,\n  clamp,\n} from './helpers'\nimport cssStyles from './styles.css'\n\nexport type CropperProps = {\n  image?: string\n  video?: string | VideoSrc[]\n  transform?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  objectFit?: 'contain' | 'horizontal-cover' | 'vertical-cover'\n  showGrid?: boolean\n  zoomSpeed: number\n  zoomWithScroll?: boolean\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropSizeChange?: (cropSize: Size) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n  disableAutomaticStylesInjection?: boolean\n  initialCroppedAreaPixels?: Area\n  initialCroppedAreaPercentages?: Area\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\n\nclass Cropper extends React.Component<CropperProps, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect' as const,\n    objectFit: 'contain' as const,\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true,\n  }\n\n  imageRef: HTMLImageElement | null = null\n  videoRef: HTMLVideoElement | null = null\n  containerRef: HTMLDivElement | null = null\n  styleRef: HTMLStyleElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.props.zoomWithScroll &&\n        this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.addEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = document.createElement('style')\n      this.styleRef.setAttribute('type', 'text/css')\n      this.styleRef.innerHTML = cssStyles\n      document.head.appendChild(this.styleRef)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef && this.imageRef.complete) {\n      this.onMediaLoad()\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.removeEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    if (this.styleRef) {\n      this.styleRef.parentNode?.removeChild(this.styleRef)\n    }\n\n    this.cleanEvents()\n    this.props.zoomWithScroll && this.clearScrollEvent()\n  }\n\n  componentDidUpdate(prevProps: CropperProps) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    } else if (\n      prevProps.cropSize?.height !== this.props.cropSize?.height ||\n      prevProps.cropSize?.width !== this.props.cropSize?.width\n    ) {\n      this.computeSizes()\n    } else if (\n      prevProps.crop?.x !== this.props.crop?.x ||\n      prevProps.crop?.y !== this.props.crop?.y\n    ) {\n      this.emitCropAreaChange()\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll\n        ? this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n        : this.clearScrollEvent()\n    }\n    if (prevProps.video !== this.props.video) {\n      this.videoRef?.load()\n    }\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    document.removeEventListener('mousemove', this.onMouseMove)\n    document.removeEventListener('mouseup', this.onDragStopped)\n    document.removeEventListener('touchmove', this.onTouchMove)\n    document.removeEventListener('touchend', this.onDragStopped)\n  }\n\n  clearScrollEvent = () => {\n    if (this.containerRef) this.containerRef.removeEventListener('wheel', this.onWheel)\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  onMediaLoad = () => {\n    const cropSize = this.computeSizes()\n\n    if (cropSize) {\n      this.emitCropData()\n      this.setInitialCrop(cropSize)\n    }\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = (cropSize: Size) => {\n    if (this.props.initialCroppedAreaPercentages) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPercentages(\n        this.props.initialCroppedAreaPercentages,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    } else if (this.props.initialCroppedAreaPixels) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n        this.props.initialCroppedAreaPixels,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    }\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef || this.videoRef\n\n    if (mediaRef && this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n      const containerAspect = this.containerRect.width / this.containerRect.height\n      const naturalWidth = this.imageRef?.naturalWidth || this.videoRef?.videoWidth || 0\n      const naturalHeight = this.imageRef?.naturalHeight || this.videoRef?.videoHeight || 0\n      const isMediaScaledDown =\n        mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight\n      const mediaAspect = naturalWidth / naturalHeight\n\n      // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n      // as the values they report are rounded. That will result in precision losses\n      // when calculating zoom. We use the fact that the media is positionned relative\n      // to the container. That allows us to use the container's dimensions\n      // and natural aspect ratio of the media to calculate accurate media size.\n      // However, for this to work, the container should not be rotated\n      let renderedMediaSize: Size\n\n      if (isMediaScaledDown) {\n        switch (this.props.objectFit) {\n          default:\n          case 'contain':\n            renderedMediaSize =\n              containerAspect > mediaAspect\n                ? {\n                    width: this.containerRect.height * mediaAspect,\n                    height: this.containerRect.height,\n                  }\n                : {\n                    width: this.containerRect.width,\n                    height: this.containerRect.width / mediaAspect,\n                  }\n            break\n          case 'horizontal-cover':\n            renderedMediaSize = {\n              width: this.containerRect.width,\n              height: this.containerRect.width / mediaAspect,\n            }\n            break\n          case 'vertical-cover':\n            renderedMediaSize = {\n              width: this.containerRect.height * mediaAspect,\n              height: this.containerRect.height,\n            }\n            break\n        }\n      } else {\n        renderedMediaSize = {\n          width: mediaRef.offsetWidth,\n          height: mediaRef.offsetHeight,\n        }\n      }\n\n      this.mediaSize = {\n        ...renderedMediaSize,\n        naturalWidth,\n        naturalHeight,\n      }\n\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            this.mediaSize.width,\n            this.mediaSize.height,\n            this.containerRect.width,\n            this.containerRect.height,\n            this.props.aspect,\n            this.props.rotation\n          )\n\n      if (\n        this.state.cropSize?.height !== cropSize.height ||\n        this.state.cropSize?.width !== cropSize.width\n      ) {\n        this.props.onCropSizeChange && this.props.onCropSizeChange(cropSize)\n      }\n      this.setState({ cropSize }, this.recomputeCropPosition)\n\n      return cropSize\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    e.preventDefault()\n    document.addEventListener('mousemove', this.onMouseMove)\n    document.addEventListener('mouseup', this.onDragStopped)\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    document.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    document.addEventListener('touchend', this.onDragStopped)\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (this.rafDragTimeout) window.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = window.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) window.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = window.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center)\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const { pixelY } = normalizeWheel(e)\n    const newZoom = this.props.zoom - (pixelY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point)\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = window.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point) => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - this.containerRect.left),\n      y: this.containerRect.height / 2 - (y - this.containerRect.top),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const zoomPoint = this.getPointOnContainer(point)\n    const zoomTarget = this.getPointOnMedia(zoomPoint)\n    const newZoom = clamp(zoom, this.props.minZoom, this.props.maxZoom)\n    const requestedPosition = {\n      x: zoomTarget.x * newZoom - zoomPoint.x,\n      y: zoomTarget.y * newZoom - zoomPoint.y,\n    }\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          requestedPosition,\n          this.mediaSize,\n          this.state.cropSize,\n          newZoom,\n          this.props.rotation\n        )\n      : requestedPosition\n\n    this.props.onCropChange(newPosition)\n    this.props.onZoomChange(newZoom)\n  }\n\n  getCropData = () => {\n    if (!this.state.cropSize) {\n      return null\n    }\n\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ricardo-ch/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    return computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n  }\n\n  emitCropData = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropComplete) {\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n    }\n\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  emitCropAreaChange = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      transform,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n      objectFit,\n    } = this.props\n\n    return (\n      <div\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={(el) => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={classNames('reactEasyCrop_Container', containerClassName)}\n      >\n        {image ? (\n          <img\n            alt=\"\"\n            className={classNames(\n              'reactEasyCrop_Image',\n              objectFit === 'contain' && 'reactEasyCrop_Contain',\n              objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n              objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n              mediaClassName\n            )}\n            {...(mediaProps as React.ImgHTMLAttributes<HTMLElement>)}\n            src={image}\n            ref={(el: HTMLImageElement) => (this.imageRef = el)}\n            style={{\n              ...mediaStyle,\n              transform:\n                transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <video\n              autoPlay\n              loop\n              muted={true}\n              className={classNames(\n                'reactEasyCrop_Video',\n                objectFit === 'contain' && 'reactEasyCrop_Contain',\n                objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n                objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n                mediaClassName\n              )}\n              {...mediaProps}\n              ref={(el: HTMLVideoElement) => (this.videoRef = el)}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform:\n                  transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            >\n              {(Array.isArray(video) ? video : [{ src: video }]).map((item) => (\n                <source key={item.src} {...item} />\n              ))}\n            </video>\n          )\n        )}\n        {this.state.cropSize && (\n          <div\n            style={{\n              ...cropAreaStyle,\n              width: this.state.cropSize.width,\n              height: this.state.cropSize.height,\n            }}\n            data-testid=\"cropper\"\n            className={classNames(\n              'reactEasyCrop_CropArea',\n              cropShape === 'round' && 'reactEasyCrop_CropAreaRound',\n              showGrid && 'reactEasyCrop_CropAreaGrid',\n              cropAreaClassName\n            )}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Cropper\n"],"names":["getCropSize","mediaWidth","mediaHeight","containerWidth","containerHeight","aspect","rotation","_a","rotateSize","width","height","fittingWidth","Math","min","fittingHeight","restrictPosition","position","mediaSize","cropSize","zoom","x","restrictPositionCoord","y","maxPosition","clamp","getDistanceBetweenPoints","pointA","pointB","sqrt","pow","getRotationBetweenPoints","atan2","PI","computeCroppedArea","crop","limitAreaFn","limitArea","noOp","mediaBBoxSize","mediaNaturalBBoxSize","naturalWidth","naturalHeight","croppedAreaPercentages","widthInPixels","round","heightInPixels","sizePixels","croppedAreaPixels","max","value","_max","getInitialCropFromCroppedAreaPercentages","minZoom","maxZoom","getInitialCropFromCroppedAreaPixels","mediaZoom","getMediaZoom","getZoomFromCroppedAreaPixels","cropZoom","getCenter","a","b","rotRad","abs","cos","sin","classNames","_i","args","filter","length","join","trim","_this","hasWheelJustStarted","e","preventDefault","document","removeEventListener","onMouseMove","onDragStopped","onTouchMove","containerRef","onWheel","wheelTimer","clearTimeout","computeSizes","emitCropData","setInitialCrop","props","onMediaLoaded","initialCroppedAreaPercentages","onCropChange","onZoomChange","initialCroppedAreaPixels","_b","mediaRef","imageRef","videoRef","containerRect","getBoundingClientRect","containerAspect","videoWidth","videoHeight","mediaAspect","renderedMediaSize","offsetWidth","offsetHeight","objectFit","state","onCropSizeChange","setState","recomputeCropPosition","addEventListener","onDragStart","Cropper","getMousePoint","onDrag","passive","touches","onPinchStart","getTouchPoint","onPinchMove","dragStartPosition","dragStartCrop","onInteractionStart","rafDragTimeout","window","cancelAnimationFrame","requestAnimationFrame","undefined","offsetX","offsetY","requestedPosition","newPosition","cleanEvents","onInteractionEnd","point","pixelY","normalizeWheel","newZoom","zoomSpeed","setNewZoom","setTimeout","Error","left","top","zoomPoint","getPointOnContainer","zoomTarget","getPointOnMedia","getAspect","cropData","getCropData","onCropComplete","onCropAreaChange","__extends","this","zoomWithScroll","preventZoomSafari","disableAutomaticStylesInjection","styleRef","createElement","setAttribute","innerHTML","head","appendChild","complete","onMediaLoad","parentNode","removeChild","clearScrollEvent","prevProps","emitCropAreaChange","video","load","lastPinchDistance","lastPinchRotation","center","rafPinchTimeout","distance","newRotation","onRotationChange","image","mediaProps","transform","cropShape","showGrid","_c","containerStyle","cropAreaStyle","mediaStyle","_d","containerClassName","cropAreaClassName","mediaClassName","React","onMouseDown","onTouchStart","ref","el","style","className","alt","src","onLoad","autoPlay","loop","muted","onLoadedMetadata","controls","Array","isArray","map","item","key","classes","Number","clientX","clientY","touch","Component"],"mappings":"sdAMgBA,EACdC,EACAC,EACAC,EACAC,EACAC,EACAC,gBAAAA,SAEMC,EAAoBC,EAAWP,EAAYC,EAAaI,GAAtDG,UAAOC,WACTC,EAAeC,KAAKC,IAAIJ,EAAON,GAC/BW,EAAgBF,KAAKC,IAAIH,EAAQN,UAEnCO,EAAeG,EAAgBT,EAC1B,CACLI,MAAOK,EAAgBT,EACvBK,OAAQI,GAIL,CACLL,MAAOE,EACPD,OAAQC,EAAeN,YAkBXU,EACdC,EACAC,EACAC,EACAC,EACAb,gBAAAA,SAEMC,EAAoBC,EAAWS,EAAUR,MAAOQ,EAAUP,OAAQJ,GAAhEG,UAAOC,iBAER,CACLU,EAAGC,EAAsBL,EAASI,EAAGX,EAAOS,EAAST,MAAOU,GAC5DG,EAAGD,EAAsBL,EAASM,EAAGZ,EAAQQ,EAASR,OAAQS,IAIlE,SAASE,EACPL,EACAC,EACAC,EACAC,OAEMI,EAAeN,EAAYE,EAAQ,EAAID,EAAW,SAEjDM,EAAMR,GAAWO,EAAaA,YAGvBE,EAAyBC,EAAeC,UAC/Cf,KAAKgB,KAAKhB,KAAKiB,IAAIH,EAAOJ,EAAIK,EAAOL,EAAG,GAAKV,KAAKiB,IAAIH,EAAON,EAAIO,EAAOP,EAAG,aAGpEU,EAAyBJ,EAAeC,UACS,IAAvDf,KAAKmB,MAAMJ,EAAOL,EAAII,EAAOJ,EAAGK,EAAOP,EAAIM,EAAON,GAAYR,KAAKoB,YAO7DC,EACdC,EACAjB,EACAC,EACAb,EACAc,EACAb,EACAS,gBADAT,kBACAS,UAIMoB,EAAcpB,EAAmBqB,EAAYC,EAE7CC,EAAgB9B,EAAWS,EAAUR,MAAOQ,EAAUP,OAAQJ,GAC9DiC,EAAuB/B,EAAWS,EAAUuB,aAAcvB,EAAUwB,cAAenC,GAInFoC,EAAyB,CAC7BtB,EAAGe,EACD,MACGG,EAAc7B,MAAQS,EAAST,MAAQU,GAAQ,EAAIe,EAAKd,EAAID,GAAQmB,EAAc7B,MACnF,KAEJa,EAAGa,EACD,MACGG,EAAc5B,OAASQ,EAASR,OAASS,GAAQ,EAAIe,EAAKZ,EAAIH,GAC/DmB,EAAc5B,OACd,KAEJD,MAAO0B,EAAY,IAAOjB,EAAST,MAAQ6B,EAAc7B,MAAS,IAAOU,GACzET,OAAQyB,EAAY,IAAOjB,EAASR,OAAS4B,EAAc5B,OAAU,IAAOS,IAIxEwB,EAAgB/B,KAAKgC,MACzBT,EACEI,EAAqB9B,MACpBiC,EAAuBjC,MAAQ8B,EAAqB9B,MAAS,MAG5DoC,EAAiBjC,KAAKgC,MAC1BT,EACEI,EAAqB7B,OACpBgC,EAAuBhC,OAAS6B,EAAqB7B,OAAU,MAS9DoC,EANqBP,EAAqB9B,OAAS8B,EAAqB7B,OAASL,EAOnF,CACEI,MAAOG,KAAKgC,MAAMC,EAAiBxC,GACnCK,OAAQmC,GAEV,CACEpC,MAAOkC,EACPjC,OAAQE,KAAKgC,MAAMD,EAAgBtC,UAmBlC,CAAEqC,yBAAwBK,2CAf5BD,IACH1B,EAAGR,KAAKgC,MACNT,EACEI,EAAqB9B,MAAQqC,EAAWrC,MACvCiC,EAAuBtB,EAAImB,EAAqB9B,MAAS,MAG9Da,EAAGV,KAAKgC,MACNT,EACEI,EAAqB7B,OAASoC,EAAWpC,OACxCgC,EAAuBpB,EAAIiB,EAAqB7B,OAAU,SAWnE,SAAS0B,EAAUY,EAAaC,UACvBrC,KAAKC,IAAImC,EAAKpC,KAAKoC,IAAI,EAAGC,IAGnC,SAASZ,EAAKa,EAAcD,UACnBA,WAMOE,EACdT,EACAzB,EACAX,EACAY,EACAkC,EACAC,OAEMf,EAAgB9B,EAAWS,EAAUR,MAAOQ,EAAUP,OAAQJ,GAG9Da,EAAOK,EACVN,EAAST,MAAQ6B,EAAc7B,OAAU,IAAMiC,EAAuBjC,OACvE2C,EACAC,SAcK,CAAEnB,KAXI,CACXd,EACGD,EAAOmB,EAAc7B,MAAS,EAC/BS,EAAST,MAAQ,EACjB6B,EAAc7B,MAAQU,GAAQuB,EAAuBtB,EAAI,KAC3DE,EACGH,EAAOmB,EAAc5B,OAAU,EAChCQ,EAASR,OAAS,EAClB4B,EAAc5B,OAASS,GAAQuB,EAAuBpB,EAAI,MAG/CH,iBAqBDmC,EACdP,EACA9B,EACAX,EACAY,EACAkC,EACAC,gBAHA/C,SAKMiC,EAAuB/B,EAAWS,EAAUuB,aAAcvB,EAAUwB,cAAenC,GAEnFa,EAAOK,EAzBf,SACEuB,EACA9B,EACAC,OAEMqC,WAvLqBtC,UAEpBA,EAAUR,MAAQQ,EAAUP,OAC/BO,EAAUR,MAAQQ,EAAUuB,aAC5BvB,EAAUP,OAASO,EAAUwB,cAmLfe,CAAavC,UAExBC,EAASR,OAASQ,EAAST,MAC9BS,EAASR,QAAUqC,EAAkBrC,OAAS6C,GAC9CrC,EAAST,OAASsC,EAAkBtC,MAAQ8C,GAiB9CE,CAA6BV,EAAmB9B,EAAWC,GAC3DkC,EACAC,GAGIK,EACJxC,EAASR,OAASQ,EAAST,MACvBS,EAASR,OAASqC,EAAkBrC,OACpCQ,EAAST,MAAQsC,EAAkBtC,YASlC,CAAEyB,KAPI,CACXd,IACImB,EAAqB9B,MAAQsC,EAAkBtC,OAAS,EAAIsC,EAAkB3B,GAAKsC,EACvFpC,IACIiB,EAAqB7B,OAASqC,EAAkBrC,QAAU,EAAIqC,EAAkBzB,GAClFoC,GAEWvC,iBAMDwC,EAAUC,EAAUC,SAC3B,CACLzC,GAAIyC,EAAEzC,EAAIwC,EAAExC,GAAK,EACjBE,GAAIuC,EAAEvC,EAAIsC,EAAEtC,GAAK,YAWLd,EAAWC,EAAeC,EAAgBJ,OAClDwD,EAAwBxD,EAPRM,KAAKoB,GAAM,UAS1B,CACLvB,MAAOG,KAAKmD,IAAInD,KAAKoD,IAAIF,GAAUrD,GAASG,KAAKmD,IAAInD,KAAKqD,IAAIH,GAAUpD,GACxEA,OAAQE,KAAKmD,IAAInD,KAAKqD,IAAIH,GAAUrD,GAASG,KAAKmD,IAAInD,KAAKoD,IAAIF,GAAUpD,aAO7Dc,EAAMyB,EAAepC,EAAamC,UACzCpC,KAAKC,IAAID,KAAKoC,IAAIC,EAAOpC,GAAMmC,YAMxBkB,qBAAWC,mBAAAA,IAAAC,yBAClBA,EACJC,QAAO,SAACpB,SACc,iBAAVA,GAAsBA,EAAMqB,OAAS,KAMjDC,KAAK,KACLC,4FC5NHC,WAAoC,KACpCA,WAAoC,KACpCA,eAAsC,KACtCA,WAAoC,KACpCA,gBAAgC,KAChCA,YAAuB,CAAEhE,MAAO,EAAGC,OAAQ,EAAG8B,aAAc,EAAGC,cAAe,GAC9EgC,oBAA2B,CAAErD,EAAG,EAAGE,EAAG,GACtCmD,gBAAuB,CAAErD,EAAG,EAAGE,EAAG,GAClCmD,oBAAoB,EACpBA,oBAAoB,EACpBA,iBAAgC,KAChCA,kBAAiC,KACjCA,aAA4B,KAE5BA,QAAe,CACbvD,SAAU,KACVwD,qBAAqB,GAsEvBD,oBAAoB,SAACE,UAAaA,EAAEC,kBAEpCH,cAAc,WACZI,SAASC,oBAAoB,YAAaL,EAAKM,aAC/CF,SAASC,oBAAoB,UAAWL,EAAKO,eAC7CH,SAASC,oBAAoB,YAAaL,EAAKQ,aAC/CJ,SAASC,oBAAoB,WAAYL,EAAKO,gBAGhDP,mBAAmB,WACbA,EAAKS,cAAcT,EAAKS,aAAaJ,oBAAoB,QAASL,EAAKU,SACvEV,EAAKW,YACPC,aAAaZ,EAAKW,aAItBX,cAAc,eACNvD,EAAWuD,EAAKa,eAElBpE,IACFuD,EAAKc,eACLd,EAAKe,eAAetE,IAGlBuD,EAAKgB,MAAMC,eACbjB,EAAKgB,MAAMC,cAAcjB,EAAKxD,YAIlCwD,iBAAiB,SAACvD,MACZuD,EAAKgB,MAAME,8BAA+B,KACtCpF,EAAiB4C,EACrBsB,EAAKgB,MAAME,8BACXlB,EAAKxD,UACLwD,EAAKgB,MAAMnF,SACXY,EACAuD,EAAKgB,MAAMrC,QACXqB,EAAKgB,MAAMpC,SANLnB,SAAMf,SASdsD,EAAKgB,MAAMG,aAAa1D,GACxBuC,EAAKgB,MAAMI,cAAgBpB,EAAKgB,MAAMI,aAAa1E,QAC9C,GAAIsD,EAAKgB,MAAMK,yBAA0B,KACxCC,EAAiBzC,EACrBmB,EAAKgB,MAAMK,yBACXrB,EAAKxD,UACLwD,EAAKgB,MAAMnF,SACXY,EACAuD,EAAKgB,MAAMrC,QACXqB,EAAKgB,MAAMpC,SANLnB,SAAMf,SASdsD,EAAKgB,MAAMG,aAAa1D,GACxBuC,EAAKgB,MAAMI,cAAgBpB,EAAKgB,MAAMI,aAAa1E,KAYvDsD,eAAe,2BACPuB,EAAWvB,EAAKwB,UAAYxB,EAAKyB,YAEnCF,GAAYvB,EAAKS,aAAc,CACjCT,EAAK0B,cAAgB1B,EAAKS,aAAakB,4BACjCC,EAAkB5B,EAAK0B,cAAc1F,MAAQgE,EAAK0B,cAAczF,OAChE8B,aAAeiC,EAAKwB,+BAAUzD,0BAAgBiC,EAAKyB,+BAAUI,aAAc,EAC3E7D,aAAgBgC,EAAKwB,+BAAUxD,2BAAiBgC,EAAKyB,+BAAUK,cAAe,EAG9EC,EAAchE,EAAeC,EAQ/BgE,YATFT,EAASU,YAAclE,GAAgBwD,EAASW,aAAelE,SAYvDgC,EAAKgB,MAAMmB,uBAEZ,UACHH,EACEJ,EAAkBG,EACd,CACE/F,MAAOgE,EAAK0B,cAAczF,OAAS8F,EACnC9F,OAAQ+D,EAAK0B,cAAczF,QAE7B,CACED,MAAOgE,EAAK0B,cAAc1F,MAC1BC,OAAQ+D,EAAK0B,cAAc1F,MAAQ+F,aAGxC,mBACHC,EAAoB,CAClBhG,MAAOgE,EAAK0B,cAAc1F,MAC1BC,OAAQ+D,EAAK0B,cAAc1F,MAAQ+F,aAGlC,iBACHC,EAAoB,CAClBhG,MAAOgE,EAAK0B,cAAczF,OAAS8F,EACnC9F,OAAQ+D,EAAK0B,cAAczF,aAKjC+F,EAAoB,CAClBhG,MAAOuF,EAASU,YAChBhG,OAAQsF,EAASW,cAIrBlC,EAAKxD,mCACAwF,IACHjE,eACAC,sBAGIvB,EAAWuD,EAAKgB,MAAMvE,SACxBuD,EAAKgB,MAAMvE,SACXlB,EACEyE,EAAKxD,UAAUR,MACfgE,EAAKxD,UAAUP,OACf+D,EAAK0B,cAAc1F,MACnBgE,EAAK0B,cAAczF,OACnB+D,EAAKgB,MAAMpF,OACXoE,EAAKgB,MAAMnF,2BAIfmE,EAAKoC,MAAM3F,+BAAUR,UAAWQ,EAASR,mBACzC+D,EAAKoC,MAAM3F,+BAAUT,SAAUS,EAAST,OAExCgE,EAAKgB,MAAMqB,kBAAoBrC,EAAKgB,MAAMqB,iBAAiB5F,GAE7DuD,EAAKsC,SAAS,CAAE7F,YAAYuD,EAAKuC,uBAE1B9F,IAcXuD,cAAc,SAACE,GACbA,EAAEC,iBACFC,SAASoC,iBAAiB,YAAaxC,EAAKM,aAC5CF,SAASoC,iBAAiB,UAAWxC,EAAKO,eAC1CP,EAAKyC,YAAYC,EAAQC,cAAczC,KAGzCF,cAAc,SAACE,UAAkBF,EAAK4C,OAAOF,EAAQC,cAAczC,KAEnEF,eAAe,SAACE,GACdE,SAASoC,iBAAiB,YAAaxC,EAAKQ,YAAa,CAAEqC,SAAS,IACpEzC,SAASoC,iBAAiB,WAAYxC,EAAKO,eAClB,IAArBL,EAAE4C,QAAQjD,OACZG,EAAK+C,aAAa7C,GACY,IAArBA,EAAE4C,QAAQjD,QACnBG,EAAKyC,YAAYC,EAAQM,cAAc9C,EAAE4C,QAAQ,MAIrD9C,cAAc,SAACE,GAEbA,EAAEC,iBACuB,IAArBD,EAAE4C,QAAQjD,OACZG,EAAKiD,YAAY/C,GACa,IAArBA,EAAE4C,QAAQjD,QACnBG,EAAK4C,OAAOF,EAAQM,cAAc9C,EAAE4C,QAAQ,MAIhD9C,cAAc,SAAClE,WAAEa,MAAGE,MAClBmD,EAAKkD,kBAAoB,CAAEvG,IAAGE,KAC9BmD,EAAKmD,4BAAqBnD,EAAKgB,MAAMvD,mBACrCuC,EAAKgB,OAAMoC,4CAGbpD,SAAS,SAAClE,OAAEa,MAAGE,MACTmD,EAAKqD,gBAAgBC,OAAOC,qBAAqBvD,EAAKqD,gBAE1DrD,EAAKqD,eAAiBC,OAAOE,uBAAsB,cAC5CxD,EAAKoC,MAAM3F,eACNgH,IAAN9G,QAAyB8G,IAAN5G,OACjB6G,EAAU/G,EAAIqD,EAAKkD,kBAAkBvG,EACrCgH,EAAU9G,EAAImD,EAAKkD,kBAAkBrG,EACrC+G,EAAoB,CACxBjH,EAAGqD,EAAKmD,cAAcxG,EAAI+G,EAC1B7G,EAAGmD,EAAKmD,cAActG,EAAI8G,GAGtBE,EAAc7D,EAAKgB,MAAM1E,iBAC3BA,EACEsH,EACA5D,EAAKxD,UACLwD,EAAKoC,MAAM3F,SACXuD,EAAKgB,MAAMtE,KACXsD,EAAKgB,MAAMnF,UAEb+H,EACJ5D,EAAKgB,MAAMG,aAAa0C,QAI5B7D,gBAAgB,mBACdA,EAAK8D,cACL9D,EAAKc,4BACLd,EAAKgB,OAAM+C,0CA+Bb/D,UAAU,SAACE,GACTA,EAAEC,qBACI6D,EAAQtB,EAAQC,cAAczC,GAC5B+D,EAAWC,UAAehE,UAC5BiE,EAAUnE,EAAKgB,MAAMtE,KAAQuH,EAASjE,EAAKgB,MAAMoD,UAAa,IACpEpE,EAAKqE,WAAWF,EAASH,GAEpBhE,EAAKoC,MAAMnC,qBACdD,EAAKsC,SAAS,CAAErC,qBAAqB,IAAQ,uCAAMD,EAAKgB,OAAMoC,oDAG5DpD,EAAKW,YACPC,aAAaZ,EAAKW,YAEpBX,EAAKW,WAAa2C,OAAOgB,YACvB,kBAAMtE,EAAKsC,SAAS,CAAErC,qBAAqB,IAAS,uCAAMD,EAAKgB,OAAM+C,oDACrE,MAIJ/D,sBAAsB,SAAClE,OAAEa,MAAGE,UACrBmD,EAAK0B,oBACF,IAAI6C,MAAM,oCAEX,CACL5H,EAAGqD,EAAK0B,cAAc1F,MAAQ,GAAKW,EAAIqD,EAAK0B,cAAc8C,MAC1D3H,EAAGmD,EAAK0B,cAAczF,OAAS,GAAKY,EAAImD,EAAK0B,cAAc+C,OAI/DzE,kBAAkB,SAAClE,OAAEa,MAAGE,MAChByE,EAAiBtB,EAAKgB,MAApBvD,SAAMf,eACP,CACLC,GAAIA,EAAIc,EAAKd,GAAKD,EAClBG,GAAIA,EAAIY,EAAKZ,GAAKH,IAItBsD,aAAa,SAACtD,EAAcsH,MACrBhE,EAAKoC,MAAM3F,UAAauD,EAAKgB,MAAMI,kBAElCsD,EAAY1E,EAAK2E,oBAAoBX,GACrCY,EAAa5E,EAAK6E,gBAAgBH,GAClCP,EAAUpH,EAAML,EAAMsD,EAAKgB,MAAMrC,QAASqB,EAAKgB,MAAMpC,SACrDgF,EAAoB,CACxBjH,EAAGiI,EAAWjI,EAAIwH,EAAUO,EAAU/H,EACtCE,EAAG+H,EAAW/H,EAAIsH,EAAUO,EAAU7H,GAElCgH,EAAc7D,EAAKgB,MAAM1E,iBAC3BA,EACEsH,EACA5D,EAAKxD,UACLwD,EAAKoC,MAAM3F,SACX0H,EACAnE,EAAKgB,MAAMnF,UAEb+H,EAEJ5D,EAAKgB,MAAMG,aAAa0C,GACxB7D,EAAKgB,MAAMI,aAAa+C,KAG1BnE,cAAc,kBACPA,EAAKoC,MAAM3F,SAcTe,EAToBwC,EAAKgB,MAAM1E,iBAClCA,EACE0D,EAAKgB,MAAMvD,KACXuC,EAAKxD,UACLwD,EAAKoC,MAAM3F,SACXuD,EAAKgB,MAAMtE,KACXsD,EAAKgB,MAAMnF,UAEbmE,EAAKgB,MAAMvD,KAGbuC,EAAKxD,UACLwD,EAAKoC,MAAM3F,SACXuD,EAAK8E,YACL9E,EAAKgB,MAAMtE,KACXsD,EAAKgB,MAAMnF,SACXmE,EAAKgB,MAAM1E,kBApBJ,MAwBX0D,eAAe,eACP+E,EAAW/E,EAAKgF,iBACjBD,OAEG9G,EAA8C8G,yBAAtBzG,EAAsByG,oBAClD/E,EAAKgB,MAAMiE,gBACbjF,EAAKgB,MAAMiE,eAAehH,EAAwBK,GAGhD0B,EAAKgB,MAAMkE,kBACblF,EAAKgB,MAAMkE,iBAAiBjH,EAAwBK,KAIxD0B,qBAAqB,eACb+E,EAAW/E,EAAKgF,iBACjBD,OAEG9G,EAA8C8G,yBAAtBzG,EAAsByG,oBAClD/E,EAAKgB,MAAMkE,kBACblF,EAAKgB,MAAMkE,iBAAiBjH,EAAwBK,KAIxD0B,wBAAwB,cACjBA,EAAKoC,MAAM3F,cAEVoH,EAAc7D,EAAKgB,MAAM1E,iBAC3BA,EACE0D,EAAKgB,MAAMvD,KACXuC,EAAKxD,UACLwD,EAAKoC,MAAM3F,SACXuD,EAAKgB,MAAMtE,KACXsD,EAAKgB,MAAMnF,UAEbmE,EAAKgB,MAAMvD,KAEfuC,EAAKgB,MAAMG,aAAa0C,GACxB7D,EAAKc,0BApeaqE,iBAqCpBzC,8BAAA,WACEY,OAAOd,iBAAiB,SAAU4C,KAAKvE,cACnCuE,KAAK3E,oBACFO,MAAMqE,gBACTD,KAAK3E,aAAa+B,iBAAiB,QAAS4C,KAAK1E,QAAS,CAAEmC,SAAS,SAClEpC,aAAa+B,iBAAiB,eAAgB4C,KAAKE,wBACnD7E,aAAa+B,iBAAiB,gBAAiB4C,KAAKE,oBAGtDF,KAAKpE,MAAMuE,uCACTC,SAAWpF,SAASqF,cAAc,cAClCD,SAASE,aAAa,OAAQ,iBAC9BF,SAASG,oiDACdvF,SAASwF,KAAKC,YAAYT,KAAKI,WAI7BJ,KAAK5D,UAAY4D,KAAK5D,SAASsE,eAC5BC,eAITrD,iCAAA,iBACEY,OAAOjD,oBAAoB,SAAU+E,KAAKvE,cACtCuE,KAAK3E,oBACFA,aAAaJ,oBAAoB,eAAgB+E,KAAKE,wBACtD7E,aAAaJ,oBAAoB,gBAAiB+E,KAAKE,oBAG1DF,KAAKI,qBACPJ,KAAKI,SAASQ,2BAAYC,YAAYb,KAAKI,gBAGxC1B,mBACA9C,MAAMqE,gBAAkBD,KAAKc,oBAGpCxD,+BAAA,SAAmByD,yBACbA,EAAUtK,WAAauJ,KAAKpE,MAAMnF,eAC/BgF,oBACA0B,yBACI4D,EAAUvK,SAAWwJ,KAAKpE,MAAMpF,YACpCiF,eACIsF,EAAUzJ,OAAS0I,KAAKpE,MAAMtE,UAClC6F,mCAEL4D,EAAU1J,+BAAUR,qBAAWmJ,KAAKpE,MAAMvE,+BAAUR,oBACpDkK,EAAU1J,+BAAUT,oBAAUoJ,KAAKpE,MAAMvE,+BAAUT,YAE9C6E,0BAELsF,EAAU1I,2BAAMd,gBAAMyI,KAAKpE,MAAMvD,2BAAMd,eACvCwJ,EAAU1I,2BAAMZ,gBAAMuI,KAAKpE,MAAMvD,2BAAMZ,SAElCuJ,qBAEHD,EAAUd,iBAAmBD,KAAKpE,MAAMqE,gBAAkBD,KAAK3E,oBAC5DO,MAAMqE,eACPD,KAAK3E,aAAa+B,iBAAiB,QAAS4C,KAAK1E,QAAS,CAAEmC,SAAS,IACrEuC,KAAKc,oBAEPC,EAAUE,QAAUjB,KAAKpE,MAAMqF,kBACjCjB,KAAK3D,yBAAU6E,SA8DnB5D,sBAAA,eACQ5G,EAAuBsJ,KAAKpE,MAA1BvE,aAAUb,kBACda,EACKA,EAAST,MAAQS,EAASR,OAE5BL,GAoKT8G,yBAAA,SAAaxC,OACLjD,EAASyF,EAAQM,cAAc9C,EAAE4C,QAAQ,IACzC5F,EAASwF,EAAQM,cAAc9C,EAAE4C,QAAQ,SAC1CyD,kBAAoBvJ,EAAyBC,EAAQC,QACrDsJ,kBAAoBnJ,EAAyBJ,EAAQC,QACrDuF,YAAYvD,EAAUjC,EAAQC,KAGrCwF,wBAAA,SAAYxC,cACJjD,EAASyF,EAAQM,cAAc9C,EAAE4C,QAAQ,IACzC5F,EAASwF,EAAQM,cAAc9C,EAAE4C,QAAQ,IACzC2D,EAASvH,EAAUjC,EAAQC,QAC5B0F,OAAO6D,GAERrB,KAAKsB,iBAAiBpD,OAAOC,qBAAqB6B,KAAKsB,sBACtDA,gBAAkBpD,OAAOE,uBAAsB,eAC5CmD,EAAW3J,EAAyBC,EAAQC,GAC5CiH,EAAUnE,EAAKgB,MAAMtE,MAAQiK,EAAW3G,EAAKuG,mBACnDvG,EAAKqE,WAAWF,EAASsC,GACzBzG,EAAKuG,kBAAoBI,MAEnB9K,EAAWwB,EAAyBJ,EAAQC,GAC5C0J,EAAc5G,EAAKgB,MAAMnF,UAAYA,EAAWmE,EAAKwG,mBAC3DxG,EAAKgB,MAAM6F,kBAAoB7G,EAAKgB,MAAM6F,iBAAiBD,GAC3D5G,EAAKwG,kBAAoB3K,MAqI7B6G,mBAAA,sBACQ5G,EAaFsJ,KAAKpE,MAZP8F,UACAT,UACAU,eACAC,cACA1F,SAAQ3E,MAAGE,MACXhB,aACAa,SACAuK,cACAC,aACAC,UAASC,mBAAgBC,kBAAeC,eACxCC,YAAWC,uBAAoBC,sBAAmBC,mBAClDvF,qBAIAwF,+BACEC,YAAaxC,KAAKwC,YAClBC,aAAczC,KAAKyC,aACnBC,IAAK,SAACC,UAAQ/H,EAAKS,aAAesH,iBACtB,YACZC,MAAOZ,EACPa,UAAWxI,EAAW,0BAA2B+H,IAEhDV,EACCa,0CACEO,IAAI,GACJD,UAAWxI,EACT,sBACc,YAAd0C,GAA2B,wBACb,qBAAdA,GAAoC,iCACtB,mBAAdA,GAAkC,+BAClCuF,IAEGX,GACLoB,IAAKrB,EACLgB,IAAK,SAACC,UAA0B/H,EAAKwB,SAAWuG,GAChDC,+BACKV,IACHN,UACEA,GAAa,aAAarK,SAAQE,gBAAehB,gBAAsBa,QAE3E0L,OAAQhD,KAAKW,eAGfM,GACEsB,4CACEU,YACAC,QACAC,OAAO,EACPN,UAAWxI,EACT,sBACc,YAAd0C,GAA2B,wBACb,qBAAdA,GAAoC,iCACtB,mBAAdA,GAAkC,+BAClCuF,IAEEX,GACJe,IAAK,SAACC,UAA0B/H,EAAKyB,SAAWsG,GAChDS,iBAAkBpD,KAAKW,YACvBiC,+BACKV,IACHN,UACEA,GAAa,aAAarK,SAAQE,gBAAehB,gBAAsBa,QAE3E+L,UAAU,KAERC,MAAMC,QAAQtC,GAASA,EAAQ,CAAC,CAAE8B,IAAK9B,KAAUuC,KAAI,SAACC,UACtDlB,6CAAQmB,IAAKD,EAAKV,KAASU,QAKlCzD,KAAKhD,MAAM3F,UACVkL,+BACEK,+BACKX,IACHrL,MAAOoJ,KAAKhD,MAAM3F,SAAST,MAC3BC,OAAQmJ,KAAKhD,MAAM3F,SAASR,uBAElB,UACZgM,UAAWxI,EACT,yBACc,UAAdwH,GAAyB,8BACzBC,GAAY,6BACZO,OA5jBL/E,eAAe,CACpBhG,KAAM,EACNb,SAAU,EACVD,OAAQ,EAAI,EACZgD,QAPa,EAQbD,QATa,EAUbsI,UAAW,OACX9E,UAAW,UACX+E,UAAU,EACVc,MAAO,GACPe,QAAS,GACThC,WAAY,GACZ3C,UAAW,EACX9H,kBAAkB,EAClB+I,gBAAgB,GA8OX3C,gBAAgB,SAACxC,SAAsC,CAC5DvD,EAAGqM,OAAO9I,EAAE+I,SACZpM,EAAGmM,OAAO9I,EAAEgJ,WAGPxG,gBAAgB,SAACyG,SAAgC,CACtDxM,EAAGqM,OAAOG,EAAMF,SAChBpM,EAAGmM,OAAOG,EAAMD,cApQEvB,UAAMyB"}